Code plan:
    - add an OperationRunner.
        TODO: do I really? I may be able to just use ModelRunner w/ no changes
    - maybe need an OperationLoader?
        - I think so. Should it be part of 'nodes' or does it need to be its own thing?
        - Toss it in 'nodes' for now...
    - wire up a thing in include/global_project/operations/adapters/postgres.sql, or something?
    - Modify the generate task's run() to do a parse run against the models first
    - use that parsed manifest to generate the flat map, etc
    - use manifest to get the list of schemas
    - flat map has the sql inside its operations -> where does that enter the call chain?

Macro/Operation execute statement or something

Make a new get_catalog macro, have operation type I create, have the operation call out to macros, do the adapter-specific work inside macros (I think)

In dbt/clients/jinja.py, MaterializationExtension - change this to 'OperationExtension' or whatever,
and it's pretty similar. Then we can do a jinja sql thingy with:

    {% operation get_catalog_data %}

        {% macros.dbt.get_catalog_data() %}

    {% endoperation %}


example:
    {% macro get_catalog() %}

      {% call statement(name='first_query') %}

        select ...

      {% endcall %}

      {% call statement(name='second_query') %}

        select ...

      {% endcall %}


      {% set df_1 = get_results('first_query')['table'] %}
      {% set df_2 = get_results('second_query')['table'] %}

      {{ return({"tables": df_1, "columns": df_2}) }}

    {% endmacro %}


clients/jinja.py